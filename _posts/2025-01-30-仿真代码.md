---
layout: post
title: "仿真代码"
date: 2026-01-30
tags: [agent, code]
toc: true
comments: true
author: wian1998
---

优化的代码，暂时保留看看需不需要修改

```python
import json
import os

from langchain_core.messages import BaseMessage
from langgraph.runtime import Runtime
from langgraph.types import Command, interrupt

from src.conf import CONF
from src.constants import LINE_FEED, Tag
from src.constants.constants import EVENT_CONFIRM
from src.constants.simulation import SIMULATION_MODEL_SCENES, SIMULATION_SCENE_TYPES
from src.graph.agent import AgentNode
from src.graph.graph_types import (
    Context,
    InterruptStruct,
    State,
    create_file_show_interrupt_struct,
)
from src.graph.validator import HumanInterruption
from src.logger import logger
from src.tools.industrial_simulation import (
    create_config_file,
    create_predict_config_file,
    industrial_simulation_software_env_check,
    validate_args,
)
from src.tools.remote_shell_exec import remote_shell_exec
from src.utils.utils import (
    log_message,
    log_message_stream,
    repair_json_output,
    wip_end,
    wip_start,
)
from src.utils.web_component import (
    CONFIRM_BUTTON,
    ENV_INSTALLED_BUTTON,
    JOB_CANCEL_BUTTON,
    LICENSE_UPLOADED_BUTTON,
    InputComponent,
    RadioComponent,
    UploadComponent,
)

starccm_picture = ""
try:
    starccm_picture = CONF.getp("software.industrial_simulation.starccm.indus_png")
except Exception:
    starccm_picture = ""
logger = logger.getChild(__name__)

ABAQUS_INPUT_CONFIGS = {
    "Cuboid": [
        {"key": "length", "placeholder": "请输入长方体的长度（单位：m）"},
        {"key": "width", "placeholder": "请输入长方体的宽度（单位：m）"},
        {"key": "height", "placeholder": "请输入长方体的高度（单位：m）"},
        {
            "key": "bulk_temperature",
            "placeholder": "请输入块材温度，默认为40℃（非必填）",
            "required": False,
            "default": 40,
        },
        {
            "key": "boundary_temperature",
            "placeholder": "请输入边界温度，默认为540℃（非必填）",
            "required": False,
            "default": 540,
        },
    ],
    "Circular": [
        {"key": "length", "placeholder": "请输入侧边圆弧长方体的长度（单位：m）"},
        {"key": "width", "placeholder": "请输入侧边圆弧内长方体的宽度（单位：m）"},
        {"key": "width2", "placeholder": "请输入侧边圆弧长方体的外边缘宽度（单位：m）"},
        {"key": "height", "placeholder": "请输入侧边圆弧长方体的高度（单位：m）"},
        {
            "key": "bulk_temperature",
            "placeholder": "请输入块材温度，默认为30℃（非必填）",
            "required": False,
            "default": 30,
        },
        {
            "key": "boundary_temperature",
            "placeholder": "请输入边界温度，默认为560℃（非必填）",
            "required": False,
            "default": 560,
        },
    ],
    "Vshape": [
        {"key": "length", "placeholder": "请输入侧边双V型长方体的长度（单位：m）"},
        {"key": "width", "placeholder": "请输入侧边双V型内长方体的宽度（单位：m）"},
        {
            "key": "width2",
            "placeholder": "请输入侧边双V型长方体的外边缘宽度（单位：m）",
        },
        {"key": "height", "placeholder": "请输入侧边双V型长方体的高度（单位：m）"},
        {
            "key": "bulk_temperature",
            "placeholder": "请输入块材温度，默认为30℃（非必填）",
            "required": False,
            "default": 30,
        },
        {
            "key": "boundary_temperature",
            "placeholder": "请输入边界温度，默认为560℃（非必填）",
            "required": False,
            "default": 560,
        },
    ],
    "Cylinder": [
        {"key": "length", "placeholder": "请输入圆柱体的高度（单位：m）"},
        {"key": "radius", "placeholder": "请输入圆柱体的半径（单位：m）"},
        {
            "key": "bulk_temperature",
            "placeholder": "请输入块材温度，默认为20℃（非必填）",
            "required": False,
            "default": 20,
        },
        {
            "key": "boundary_temperature",
            "placeholder": "请输入边界温度，默认为200℃（非必填）",
            "required": False,
            "default": 200,
        },
    ],
}

ABAQUS_TYPES = {
    "Cuboid": "长方体结构",
    "Circular": "侧边圆弧长方体结构",
    "Vshape": "侧边双V型长方体结构",
    "Cylinder": "圆柱体结构",
}

MODEL_TYPES = [
    "absorber",
    "bend",
    "bending_anti_collision",
    "creep",
    "cup_forming",
    "Hardness",
    "Radiator",
    "shearing",
    "stiffened_plate_buckling",
    "tensile",
]

# 模板映射常量
ABAQUS_TEMPLATE_MAP = {
    "Cuboid": "CUBOID_JSON_TEMPLATE",
    "Circular": "CIRCULAR_JSON_TEMPLATE",
    "Vshape": "VSHAPE_JSON_TEMPLATE",
    "Cylinder": "CYLINDER_JSON_TEMPLATE",
}

COMPOSITE_CABLE_TEMPLATE_MAP = {
    "first": "COMPOSITE_CABLE_FIRST_JSON_TEMPLATE",
    "second": "COMPOSITE_CABLE_SECOND_JSON_TEMPLATE"
}

# 复合电缆阶段配置
COMPOSITE_CABLE_STAGE_CONFIG = {
    "first": {
        "input_configs": [{"key": "length", "placeholder": "请输入线缆长度（单位：mm）"}],
        "describe": "请填写钢芯铝绞线参数"
    },
    "second": {
        "input_configs": [{"key": "drawing_force", "placeholder": "请输入拉伸力（单位：N）"}],
        "describe": "请填写拉伸力"
    }
}

def create_input_components(input_configs: list[dict]) -> list:
    """
    根据输入配置创建输入组件列表
    """
    components = []
    
    # 参数验证
    if not isinstance(input_configs, list):
        logger.error("输入配置必须是列表类型")
        return [CONFIRM_BUTTON]
    
    for config in input_configs:
        if not isinstance(config, dict):
            logger.warning(f"输入配置项必须是字典类型，跳过无效配置: {config}")
            continue
            
        try:
            # 检查必要的字段
            key = config.get("key")
            placeholder = config.get("placeholder")
            
            if not key:
                logger.warning(f"输入配置项缺少key字段，跳过无效配置: {config}")
                continue
            
            if not placeholder:
                logger.warning(f"输入配置项缺少placeholder字段，使用默认提示: {config}")
                placeholder = f"请输入{key}"
            
            # 创建输入组件
            components.append(
                InputComponent(
                    key=key,
                    value="" if "default" not in config else str(config["default"]),
                    placeholder=placeholder,
                    required=config.get("required", True),
                )
            )
        except Exception as e:
            logger.error(f"创建输入组件时出现错误: {e}", exc_info=True)
            continue
    
    components.append(CONFIRM_BUTTON)
    return components

def create_interrupt_and_get_feedback(components: list, describe: str, component_type: str = "form-card") -> dict:
    """
    创建中断结构并获取用户反馈
    
    Args:
        components: 输入组件列表
        describe: 中断描述信息
        component_type: 组件类型，默认为"form-card"
        
    Returns:
        用户反馈信息字典
    """
    # 参数验证
    if not components:
        logger.error("组件列表不能为空")
        raise ValueError("组件列表不能为空")
    
    if not describe or not isinstance(describe, str):
        logger.error("描述信息必须是一个非空字符串")
        raise ValueError("描述信息必须是一个非空字符串")
    
    # 确保component_type是字符串类型
    if not isinstance(component_type, str):
        component_type = "form-card"
        logger.warning(f"组件类型必须是字符串，已自动设置为默认值：{component_type}")
    
    try:
        interruption = InterruptStruct(
            component=components,
            describe=describe,
            componentType=component_type,
        ).model_dump()
        feedback = interrupt(interruption)
        logger.info(f"将任务转交human，已获取到反馈，反馈内容：{feedback}")
        return feedback
    except Exception as e:
        logger.error(f"创建中断或获取反馈时出现错误: {e}")
        raise

def process_parameters(input_configs: list[dict], content: dict) -> dict:
    """
    处理参数，统一处理默认值和类型转换
    
    Args:
        input_configs: 参数配置列表
        content: 用户输入的参数内容
        
    Returns:
        处理后的参数字典，包含正确的类型转换
    """
    # 参数验证
    if not isinstance(input_configs, list):
        logger.error("参数配置必须是列表类型")
        raise ValueError("参数配置必须是列表类型")
    
    if not isinstance(content, dict):
        content = {}
        logger.warning(f"用户输入内容必须是字典类型，已自动设置为空字典")
    
    args = {}
    for config in input_configs:
        if not isinstance(config, dict):
            logger.warning(f"参数配置项必须是字典类型，跳过无效配置: {config}")
            continue
            
        key = config.get("key")
        if not key:
            logger.warning(f"参数配置项缺少key字段，跳过无效配置: {config}")
            continue
        
        # 检查是否需要使用默认值
        if key not in content:
            args[key] = config.get("default", "")
        else:
            value = content.get(key, "")
            default_value = config.get("default", "")
            
            # 根据默认值类型或配置中的type字段进行类型转换
            try:
                # 如果配置中指定了类型
                if "type" in config:
                    type_name = config["type"]
                    if type_name == "int":
                        args[key] = int(value)
                    elif type_name == "float":
                        args[key] = float(value)
                    elif type_name == "bool":
                        args[key] = bool(value)
                    elif type_name == "list":
                        args[key] = list(value)
                    elif type_name == "dict":
                        args[key] = dict(value)
                    else:
                        args[key] = value
                # 根据默认值类型进行转换
                elif default_value is not None and value != "":
                    if isinstance(default_value, int):
                        args[key] = int(value)
                    elif isinstance(default_value, float):
                        args[key] = float(value)
                    elif isinstance(default_value, bool):
                        args[key] = bool(value)
                    elif isinstance(default_value, list):
                        args[key] = list(value)
                    elif isinstance(default_value, dict):
                        args[key] = dict(value)
                    else:
                        args[key] = value
                else:
                    args[key] = value
            except (ValueError, TypeError) as e:
                logger.warning(f"参数 {key} 的值 {value} 转换类型失败，使用原始值: {e}")
                args[key] = value
    
    return args

MODEL_INPUT_CONFIGS = {
    "absorber": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物弹性模量（输入范围 50000——250000，默认为 210000）",
            "required": False,
            "default": 210000,
        },
        {
            "key": "second_param",
            "placeholder": "请输入被测物压缩位移（输入范围 -1.5——-0.5，默认为 -1）",
            "required": False,
            "default": -1,
        },
    ],
    "bend": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物弹性模量（输入范围 50000——250000，默认为 210000）",
            "required": False,
            "default": 210000,
        },
        {
            "key": "second_param",
            "placeholder": "请输入被测物下压力（输入范围 -3500——-2000，默认为 -3000）",
            "required": False,
            "default": -3000,
        },
    ],
    "bending_anti_collision": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物弹性模量（输入范围 50000——250000，默认为 210000）",
            "required": False,
            "default": 210000,
        },
        {
            "key": "second_param",
            "placeholder": "请输入被测物侵入位移（输入范围 30——70，默认为 60）",
            "required": False,
            "default": 60,
        },
    ],
    "creep": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物边界载荷（输入范围 -50.0--10.0，默认为 -10.0）",
            "required": False,
            "default": -10.0,
        }
    ],
    "cup_forming": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物弹性模量（输入范围 2000-5000，默认为 4000）",
            "required": False,
            "default": 4000,
        }
    ],
    "Hardness": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物弹性模量（输入范围 50000——250000，默认为 100000）",
            "required": False,
            "default": 100000,
        },
        {
            "key": "second_param",
            "placeholder": "请输入被测物压入深度（输入范围 -1.2——-0.5，默认为 -1）",
            "required": False,
            "default": -1,
        },
    ],
    "Radiator": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物热传导系数（输入范围 800000.0——1000000.0，默认为 896000.0）",
            "required": False,
            "default": 896000.0,
        }
    ],
    "shearing": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物弹性模量（输入范围 50000——250000，默认为 69000）",
            "required": False,
            "default": 69000,
        },
        {
            "key": "second_param",
            "placeholder": "请输入被测物剪切测试拉伸位移（输入范围 -15——-5，默认为 -10）",
            "required": False,
            "default": -10,
        },
    ],
    "stiffened_plate_buckling": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物弹性模量（输入范围 50000——250000，默认为 73200）",
            "required": False,
            "default": 73200,
        },
        {
            "key": "second_param",
            "placeholder": "请输入被测物压缩位移（输入范围 -15--5，默认为 -15）",
            "required": False,
            "default": -15,
        },
    ],
    "tensile": [
        {
            "key": "first_param",
            "placeholder": "请输入被测物弹性模量（输入范围 50000——250000，默认为 69000）",
            "required": False,
            "default": 69000,
        },
        {
            "key": "second_param",
            "placeholder": "请输入被测物压缩位移（输入范围 0.2——0.4，默认为 0.33）",
            "required": False,
            "default": 0.33,
        },
    ],
}

class PrecheckSimulation(AgentNode):
    """
    工业仿真计算预检查节点，检查用户提问的场景是否在我们计算场景内。
    """

    def __init__(self, name: str, prompt_name: str = None, tags: list[Tag] = None):
        if tags is None:
            tags = []
        super().__init__(name=name, prompt_name=prompt_name, tags=tags)

    def execute(self, messages: list[BaseMessage]) -> BaseMessage:
        self.p("start")
        execution_chain = self.create_execution_chain()
        response = execution_chain.invoke(messages)
        self.p("result", response.content)
        self.p("end")
        return response

def classify_simulation_node(state: State, runtime: Runtime[Context]):
    """
    工业仿真计算分类节点，根据用户输入的计算类型，选择不同的计算软件。
    """
    logger.info("进入工业仿真计算分类节点...")
    params = state.params

    try:
        wip_start()
        log_message_stream("正在确认您的计算任务")
        response = PrecheckSimulation(name="precheck_simulation").execute(messages=state.messages)
        scene_result = json.loads(repair_json_output(response.content).strip())
        scene = scene_result.get("scene", "other")
        logger.info(f"仿真意图识别结果: {scene}")
        wip_end()
    except Exception as e:
        logger.error(f"意图识别出现错误:{e}")
        scene = "other"

    next = "classify_simulation_interrupt" if scene not in SIMULATION_SCENE_TYPES else "validator_queue"
    params.update({"scene": scene})

    return Command(update={"current": "classify_simulation", "next": next, "params": params})

def classify_simulation_interrupt_node(state: State, runtime: Runtime[Context]):
    """
    仿真中断节点，不同任务的预处理和输入不同，需要前置选择逻辑
    """

    logger.info("未确定执行任务，仿真任务分类中断节点执行中...")

    valid_scene = [{"label": value, "value": key} for key, value in SIMULATION_SCENE_TYPES.items()]

    interruption = InterruptStruct(
        component=[
            RadioComponent(
                options=valid_scene,
                key="scene",
                name="请选择你的仿真计算目标",
                value="vehicle_aerodynamic_drag",
            ),
            CONFIRM_BUTTON,
        ],
        describe="请选择你的仿真任务计算目标",
        componentType="form-card",
    ).model_dump()

    feedback = interrupt(interruption)

    content = feedback.get("content", "")
    scene = content.get("scene")

    logger.info(f"中断已完成，用户选择的计算场景是: {scene}")

    params = state.params
    params.update({"scene": scene})

    return Command(
        update={
            "current": "classify_simulation_interrupt",
            "next": "validator_queue",
            "params": params,
        }
    )

def validator_industrial_simulation_node(state: State, runtime: Runtime[Context]):
    """
    针对不同计算场景，进行不同的逻辑处理
    """
    logger.info("进入工业仿真计算验证节点...")
    params = state.params
    scene = params.get("scene")
    cluster_id = state.clusterId
    username = runtime.context.username

    # 1.整车外流场风阻计算需要检查环境
    if scene == "vehicle_aerodynamic_drag":
        # 2.检查用户环境
        result = industrial_simulation_software_env_check(
            software_name="starccm", cluster_id=cluster_id, username=username
        )

        if result["status"] == "pass":
            return Command(
                update={
                    "current": "validator_industrial_simulation",
                    "next": "executor_industrial_simulation_pre",
                }
            )
        if result["status"] == "software":
            wip_end()
            result_card = result["message"]
            params.update({"download_card": result_card})
            return Command(
                update={
                    "current": "validator_industrial_simulation",
                    "next": "executor_download_software",
                    "params": params,
                },
            )
        if result["status"] == "license":
            wip_end()
            return Command(
                update={
                    "current": "validator_industrial_simulation",
                    "next": "executor_upload_license",
                }
            )
    elif scene == "composite_cable_simulation":
        # 直接去planner
        params.update({"planner_name": "INDUSTRIAL_SIMULATION"})
        return Command(
            update={
                "current": "validator_industrial_simulation",
                "next": "planner",
                "params": params,
            }
        )
    elif scene in MODEL_TYPES:
        # config文件生成节点
        return Command(
            update={
                "current": "validator_industrial_simulation",
                "next": "executor_industrial_simulation_config_file",
            }
        )

    return Command(
        update={
            "current": "validator_industrial_simulation",
            "next": "executor_industrial_simulation_pre",
        }
    )

def executor_download_software_node(state: State, runtime: Runtime[Context]):
    """
    下载工业仿真计算软件节点
    """
    logger.info("进入下载软件节点...")
    params = state.params
    download_card = params.get("download_card")
    components = download_card
    components.append(ENV_INSTALLED_BUTTON)
    logger.info("选择下载卡片")
    scene = params.get("scene")
    if scene == "vehicle_aerodynamic_drag":
        pass
    else:
        log_message_stream("该软件暂未开放，任务结束。")
        return Command(update={"current": "executor_download_software", "next": "__end__"})
    response = InterruptStruct(
        component=components,
        describe="请安装STAR-CCM 16.04.012版本",
        componentType="goods-list",
    ).model_dump()
    human_inputs = HumanInterruption.prompt_choice(response)
    event = human_inputs.get("event")

    if event == EVENT_CONFIRM:
        return Command(
            update={
                "current": "executor_download_software",
                "next": "validator_industrial_simulation",
            },
        )
    log_message_stream("事件错误，请重试")
    return Command(update={"current": "executor_download_software", "next": "__end__"})

def executor_upload_license_node(state: State, runtime: Runtime[Context]):
    """
    上传工业仿真计算软件license节点
    """
    logger.info("进入上传license节点...")
    params = state.params
    cluster_id = state.clusterId
    username = runtime.context.username
    scene = params.get("scene")
    software_name = "starccm" if scene == "vehicle_aerodynamic_drag" else "other"
    if software_name == "starccm":
        # 获取用户家目录路径
        try:
            user_home = remote_shell_exec(username=username, code="cd ~ && pwd", cluster_id=cluster_id)
            home_path = user_home["output"].strip()  # 移除可能的换行符
            license_path = os.path.join(home_path, "apprepo", "starccmplus", "16.04.012-null", "app")
        except Exception as e:
            logger.error(f"获取用户家目录失败: {e}")
            log_message_stream("获取用户家目录失败，任务结束。")
            return Command(update={"current": "executor_upload_license", "next": "__end__"})
    else:
        return Command(update={"current": "executor_upload_license", "next": "__end__"})
    components = [
        UploadComponent(
            name="请将license文件上传到此处",
            key="license",
            value="",
            clusterId=cluster_id,
            filePath=f"{license_path}",
            acceptType=".dat",
        ),
        JOB_CANCEL_BUTTON,
        LICENSE_UPLOADED_BUTTON,
    ]

    params.update({"describe": "确认信息"})
    params.update({"componentType": "form-card"})

    return Command(
        update={
            "components": components,
            "current": "executor_upload_license",
            "next": "upload_file",
            "params": params,
        },
    )

def executor_industrial_simulation_pre_node(state: State, runtime: Runtime[Context]):
    """
    工业仿真预处理节点，根据不同场景，展示不同内容
    """
    params = state.params
    scene = params.get("scene")

    logger.info("进入工业仿真模型文件标准节点...")

    if scene == "vehicle_aerodynamic_drag":
        indus_example_url = (
            "https://oss.ksai.scnet.cn:58043/test/picture/yiziqinx/indus_example.png"
            if starccm_picture == ""
            else starccm_picture
        )

        model_description = f"上传的模型需要满足以下几点要求：{LINE_FEED}1. 模型要求水密{LINE_FEED}2. 几何模型命名为carsurface.stl{LINE_FEED}3. 建模时坐标系位置如图所示，坐标原点在距离车头1/4位置，+x方向为来流方向{LINE_FEED}"
        wip_start()
        log_message(f"输入模型要求{LINE_FEED}{model_description}{LINE_FEED}")
        wip_end()
        log_message(f'<img src="{indus_example_url}" width="100%"/>')

        return Command(
            update={
                "current": "executor_industrial_simulation_pre",
                "next": "executor_industrial_simulation_upload",
            }
        )
    if scene == "aluminum_homogenization":
        operating_condition_options = [{"label": value, "value": key} for key, value in ABAQUS_TYPES.items()]

        interrupt_struct = InterruptStruct(
            component=[
                RadioComponent(
                    options=operating_condition_options,
                    key="operating_condition",
                    name="请选择您要计算的几何结构",
                    value="Cuboid",
                ),
                CONFIRM_BUTTON,
            ],
            describe="请选择您要计算的几何结构",
            componentType="form-card",
        ).model_dump()

        feedback = interrupt(interrupt_struct)
        logger.info(f"将任务转交human，已获取到反馈，反馈内容：{feedback}")

        content = feedback.get("content")
        operating_condition = content.get("operating_condition")

        logger.info(f"中断已完成，用户选择的结构工况是: {operating_condition}")

        params.update({"operating_condition": operating_condition})
        return Command(
            update={
                "current": "executor_industrial_simulation_pre",
                "next": "executor_industrial_simulation_config_file",
                "params": params,
            }
        )
    if scene == "composite_cable_simulation":
        return Command(
            update={
                "current": "executor_industrial_simulation_pre",
                "next": "executor_industrial_simulation_config_file",
            }
        )
    return None

def executor_industrial_simulation_upload_node(state: State, runtime: Runtime[Context]):
    """
    工业仿真文件输入文件上传节点
    """
    logger.info("进入工业仿真文件上传节点...")
    params = state.params

    work_dir = state.work_dir
    cluster_id = state.clusterId
    scene = params.get("scene")
    components = []

    if scene == "vehicle_aerodynamic_drag":
        components = [
            UploadComponent(
                name="请按照要求上传模型文件",
                key="model",
                value="",
                clusterId=cluster_id,
                filePath=f"{work_dir}",
                acceptType=".stl",
            ),
            JOB_CANCEL_BUTTON,
            CONFIRM_BUTTON,
        ]

    params.update({"describe": "确认信息"})
    params.update({"componentType": "form-card"})

    return Command(
        update={
            "components": components,
            "current": "executor_industrial_simulation_upload",
            "next": "upload_file",
            "params": params,
        },
    )

def executor_industrial_simulation_process_upload_file_node(state: State, runtime: Runtime[Context]):
    params = state.params

    content = params.get("content")
    username = runtime.context.username
    cluster_id = state.clusterId

    model_path = content.get("model", "")
    # 将用户上传的文件重命名为carsurface.stl
    # 从model_path中获取不含文件名的路径
    current_model_dir = os.path.dirname(model_path)
    try:
        remote_shell_exec(
            username,
            f"mv '{model_path}' '{os.path.join(current_model_dir, 'carsurface.stl')}'",
            cluster_id=cluster_id,
        )
        model_path = os.path.join(current_model_dir, "carsurface.stl")
    except Exception as e:
        logger.error(f"重命名模型文件失败: {e}")
        log_message_stream("重命名模型文件失败，任务结束。")
        return Command(update={"current": "executor_industrial_simulation_process_upload_file", "next": "__end__"})
    model_name = os.path.basename(model_path)
    # 更新参数
    params.update({"model_path": model_path})
    params.update({"model_name": model_name})

    logger.info(f"用户上传的模型文件名: {model_name}，用户上传或选择的模型文件路径: {model_path}")

    return Command(
        update={
            "current": "executor_industrial_simulation_process_upload_file",
            "next": "executor_industrial_simulation_config_file",
            "params": params,
        }
    )

def handle_vehicle_aerodynamic_drag(params: dict, work_dir: str, cluster_id: str, username: str, model_path: str):
    """
    处理整车外流场风阻计算场景的配置文件创建
    """
    # 参数补充输入框
    input_configs = [
        {"key": "x_min", "placeholder": "请输入X轴最小值"},
        {"key": "y_min", "placeholder": "请输入Y轴最小值"},
        {"key": "z_min", "placeholder": "请输入Z轴最小值"},
        {"key": "x_max", "placeholder": "请输入X轴最大值"},
        {"key": "y_max", "placeholder": "请输入Y轴最大值"},
        {"key": "z_max", "placeholder": "请输入Z轴最大值"},
    ]
    components = create_input_components(input_configs)

    feedback = create_interrupt_and_get_feedback(components, "请输入汽车几何边界框")
    content = feedback.get("content", "")
    event = feedback.get("event", "")

    if event == EVENT_CONFIRM:
        args = process_parameters(input_configs, content)
        result = create_config_file(
            args,
            model_path,
            work_dir,
            username,
            cluster_id,
            "STARCCM_CONFIG_TEMPLATE",
        )

        if result["success"]:
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_file",
                    "next": "executor_industrial_simulation_config_show",
                },
            )
        return Command(
            update={
                "current": "executor_industrial_simulation_config_file",
                "next": "__end__",
            }
        )
    log_message_stream("您已取消配置，任务结束。")
    return Command(
        update={
            "current": "executor_industrial_simulation_config_file",
            "next": "__end__",
        }
    )

def handle_aluminum_homogenization(params: dict, work_dir: str, cluster_id: str, username: str):
    """
    处理铝均质化场景的配置文件创建
    """
    operating_condition = params.get("operating_condition")
    model_path = ""

    if operating_condition in ABAQUS_INPUT_CONFIGS:
        # 创建输入组件
        input_configs = ABAQUS_INPUT_CONFIGS[operating_condition]
        components = create_input_components(input_configs)
        describe = f"请输入{ABAQUS_TYPES[operating_condition]}的相关参数"
        feedback = create_interrupt_and_get_feedback(components, describe)

        content = feedback.get("content", "")
        event = feedback.get("event", "")

        if event == EVENT_CONFIRM:
            # 构建参数字典
            args = process_parameters(input_configs, content)

            # 根据操作条件选择正确的模板
            template_name = ABAQUS_TEMPLATE_MAP.get(operating_condition, "CUBOID_JSON_TEMPLATE")

            logger.info(f"创建配置文件，参数：{args}")
            result = create_config_file(args, model_path, work_dir, username, cluster_id, template_name)

            if result["success"]:
                return Command(
                    update={
                        "current": "executor_industrial_simulation_config_file",
                        "next": "executor_industrial_simulation_config_show",
                    },
                )
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_file",
                    "next": "__end__",
                }
            )
        log_message_stream("您已取消配置，任务结束。")
        return Command(
            update={
                "current": "executor_industrial_simulation_config_file",
                "next": "__end__",
            }
        )
    return Command(
        update={
            "current": "executor_industrial_simulation_config_file",
            "next": "__end__",
        }
    )

def handle_composite_cable_stage(stage: str, input_configs: list[dict], describe: str, conversation_id: str, work_dir: str, cluster_id: str, username: str, model_path: str):
    """
    处理复合电缆模拟的单个阶段
    """
    # 创建输入组件
    components = create_input_components(input_configs)
    
    # 获取用户反馈
    feedback = create_interrupt_and_get_feedback(components, describe)
    content = feedback.get("content", "")
    event = feedback.get("event", "")
    
    if event == EVENT_CONFIRM:
        # 构建参数字典
        args = process_parameters(input_configs, content)
        args["conversation_id"] = conversation_id
        
        # 根据阶段选择模板
        template_name = COMPOSITE_CABLE_TEMPLATE_MAP.get(stage, "COMPOSITE_CABLE_FIRST_JSON_TEMPLATE")
        
        # 创建配置文件
        result = create_config_file(
            args,
            model_path,
            work_dir,
            username,
            cluster_id,
            template_name,
        )
        
        if result["success"]:
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_file",
                    "next": "executor_industrial_simulation_config_show",
                },
            )
        return Command(
            update={
                "current": "executor_industrial_simulation_config_file",
                "next": "__end__",
            }
        )
    log_message_stream("您已取消配置，任务结束。")
    return Command(
        update={
            "current": "executor_industrial_simulation_config_file",
            "next": "__end__",
        }
    )

def handle_composite_cable_simulation(params: dict, work_dir: str, cluster_id: str, username: str, runtime: Runtime[Context]):
    """
    处理复合电缆模拟场景的配置文件创建
    """
    stage = params.get("stage", "first")  # 默认使用第一阶段
    conversation_id = runtime.context.conversationId
    model_path = " "
    
    # 使用映射获取阶段配置
    stage_config = COMPOSITE_CABLE_STAGE_CONFIG.get(stage)
    if stage_config:
        input_configs = stage_config["input_configs"]
        describe = stage_config["describe"]
        return handle_composite_cable_stage(stage, input_configs, describe, conversation_id, work_dir, cluster_id, username, model_path)
    else:
        logger.error(f"无效的复合电缆模拟阶段: {stage}")
        log_message_stream(f"无效的模拟阶段: {stage}，任务结束。")
        return Command(
            update={
                "current": "executor_industrial_simulation_config_file",
                "next": "__end__",
            }
        )

def handle_model_types(scene: str, params: dict, work_dir: str, cluster_id: str, username: str, current: str):
    """
    处理模型类型场景的配置文件创建
    """
    try:
        # 创建输入组件
        if scene not in MODEL_INPUT_CONFIGS:
            logger.error(f"场景{scene}的输入配置不存在")
            log_message_stream(f"场景{scene}的输入配置不存在，任务结束。")
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_file",
                    "next": "__end__",
                }
            )
            
        input_configs = MODEL_INPUT_CONFIGS[scene]
        components = create_input_components(input_configs)
        
        # 生成描述信息
        scene_name = SIMULATION_MODEL_SCENES.get(scene, scene)
        describe = (
            f"请重新输入{scene_name}的相关参数"
            if current == "executor_industrial_simulation_config_file"
            else f"请输入{scene_name}的相关参数"
        )
        
        feedback = create_interrupt_and_get_feedback(components, describe)

        content = feedback.get("content", "")
        event = feedback.get("event", "")

        if event == EVENT_CONFIRM:
            # 构建参数字典
            args = process_parameters(input_configs, content)

            wip_start()
            log_message("验证输入参数")
            result = validate_args(args=args, scene=scene)
            log_message_stream(result["message"])
            wip_end()
            if not result["success"]:
                return Command(
                    update={
                        "current": "executor_industrial_simulation_config_file",
                        "next": "executor_industrial_simulation_config_file",
                    }
                )

            logger.info(f"创建配置文件，参数：{args}")
            result = create_predict_config_file(
                args=args,
                work_dir=work_dir,
                username=username,
                cluster_id=cluster_id,
                scene=scene,
            )

            if result["success"]:
                return Command(
                    update={
                        "current": "executor_industrial_simulation_config_file",
                        "next": "executor_industrial_simulation_config_show",
                    },
                )
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_file",
                    "next": "__end__",
                }
            )
        log_message_stream("您已取消配置，任务结束。")
        return Command(
            update={
                "current": "executor_industrial_simulation_config_file",
                "next": "__end__",
            }
        )
    except Exception as e:
        logger.error(f"处理模型类型场景时出现错误: {e}", exc_info=True)
        log_message_stream(f"处理过程中出现错误: {e}，任务结束。")
        return Command(
            update={
                "current": "executor_industrial_simulation_config_file",
                "next": "__end__",
            }
        )

def executor_industrial_simulation_config_file_node(state: State, runtime: Runtime[Context]):
    """
    配置文件配置节点
    """
    logger.info("进入配置文件配置节点...")

    try:
        # 基本参数验证
        if not state or not hasattr(state, 'params') or not hasattr(state, 'work_dir') or not hasattr(state, 'clusterId'):
            logger.error("状态对象格式不正确，缺少必要属性")
            log_message_stream("状态对象格式不正确，任务结束。")
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_file",
                    "next": "__end__",
                }
            )
            
        params = state.params
        work_dir = state.work_dir
        cluster_id = state.clusterId
        current = state.current
        
        if not runtime or not hasattr(runtime, 'context') or not hasattr(runtime.context, 'username'):
            logger.error("运行时上下文格式不正确，缺少必要属性")
            log_message_stream("运行时上下文格式不正确，任务结束。")
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_file",
                    "next": "__end__",
                }
            )
            
        username = runtime.context.username
        scene = params.get("scene")

        if not scene:
            logger.error("未指定场景类型")
            log_message_stream("未指定场景类型，任务结束。")
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_file",
                    "next": "__end__",
                }
            )
            
        if scene == "vehicle_aerodynamic_drag":
            model_path = params.get("model_path")
            return handle_vehicle_aerodynamic_drag(params, work_dir, cluster_id, username, model_path)
        
        if scene == "aluminum_homogenization":
            return handle_aluminum_homogenization(params, work_dir, cluster_id, username)
        
        if scene == "composite_cable_simulation":
            return handle_composite_cable_simulation(params, work_dir, cluster_id, username, runtime)
        
        if scene in MODEL_TYPES:
            return handle_model_types(scene, params, work_dir, cluster_id, username, current)
        
        logger.warning(f"未知的场景类型: {scene}")
        log_message_stream(f"未知的场景类型: {scene}，任务结束。")
        return Command(
            update={
                "current": "executor_industrial_simulation_config_file",
                "next": "__end__",
            }
        )
    except Exception as e:
        logger.error(f"配置文件生成节点执行时出现错误: {e}", exc_info=True)
        log_message_stream(f"配置文件生成过程中出现错误: {e}，任务结束。")
        return Command(
            update={
                "current": "executor_industrial_simulation_config_file",
                "next": "__end__",
            }
        )

def show_config_file_and_get_feedback(file_path: str, describe: str):
    """
    展示配置文件并获取用户反馈
    """
    try:
        # 检查文件是否存在
        if not os.path.exists(file_path):
            logger.error(f"配置文件不存在: {file_path}")
            log_message_stream(f"配置文件不存在: {file_path}")
            return
            
        # 检查是否有读取权限
        if not os.access(file_path, os.R_OK):
            logger.error(f"没有权限读取配置文件: {file_path}")
            log_message_stream(f"没有权限读取配置文件: {file_path}")
            return
            
        response = create_file_show_interrupt_struct(file_path, describe)
        feedback = interrupt(dict(response))
        logger.info(f"将任务转交human，已获取到反馈，反馈内容：{feedback}")
    except Exception as e:
        logger.error(f"展示配置文件时出现错误: {e}")
        log_message_stream(f"展示配置文件失败: {e}")

def executor_industrial_simulation_config_show_node(state: State, runtime: Runtime[Context]) -> Command:
    """
    配置文件展示节点
    
    Args:
        state: 当前状态
        runtime: 运行时上下文
        
    Returns:
        下一个节点的命令
    """
    logger.info("进入配置文件展示节点...")
    params = state.params
    work_dir = state.work_dir
    params.update({"planner_name": "INDUSTRIAL_SIMULATION"})

    scene = params.get("scene")
    
    # 统一的配置文件映射结构 - 合并所有场景配置
    CONFIG_FILE_MAPPING = {
        "vehicle_aerodynamic_drag": {
            "file_name": "config.json",
            "next_node": "planner"
        },
        "aluminum_homogenization": {
            "file_name": "sh_simulation_input.json",
            "next_node": "planner"
        },
        "composite_cable_simulation": {
            "file_mapping": {
                "first": "composite_cable_first_input.json",
                "second": "composite_cable_second_input.json"
            },
            "next_node": "executor_composite_cable_simulation"
        },
        "model_types": {
            "file_name": "predict_param.json",
            "next_node": "planner"
        }
    }
    
    try:
        # 确定场景配置和文件名
        if scene in CONFIG_FILE_MAPPING:
            scene_config = CONFIG_FILE_MAPPING[scene]
            
            # 处理复合电缆模拟场景（需要根据阶段获取文件名）
            if scene == "composite_cable_simulation" and "file_mapping" in scene_config:
                stage = params.get("stage", "first")
                file_name = scene_config["file_mapping"].get(stage, "composite_cable_first_input.json")
            else:
                file_name = scene_config["file_name"]
            
            # 展示配置文件并获取反馈
            show_config_file_and_get_feedback(os.path.join(work_dir, file_name), "配置文件展示")
            
            # 返回下一个节点命令
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_show",
                    "next": scene_config["next_node"],
                    "params": params,
                }
            )
        elif scene in MODEL_TYPES:
            # 模型类型场景，使用model_types配置
            scene_config = CONFIG_FILE_MAPPING["model_types"]
            file_name = scene_config["file_name"]
            show_config_file_and_get_feedback(os.path.join(work_dir, file_name), "配置文件展示")
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_show",
                    "next": scene_config["next_node"],
                    "params": params,
                }
            )
        else:
            logger.warning(f"未知的场景类型: {scene}，跳过配置文件展示")
            return Command(
                update={
                    "current": "executor_industrial_simulation_config_show",
                    "next": "planner",
                    "params": params,
                }
            )
    except Exception as e:
        logger.error(f"展示配置文件时出现错误: {e}")
        log_message_stream(f"展示配置文件失败: {e}")
        return Command(
            update={
                "current": "executor_industrial_simulation_config_show",
                "next": "__end__",
            }
        )
```

  智能体开发环境仿真与适配问题总结
  一、第三方仿真环境迁移问题 
  本期代理模型所需基础环境基于Ubuntu 22.04构建，环境依赖较为复杂，在向目标集群迁移过程中主要遇到以下问题： 
  1. 集群侧的计算节点（CentOS系统）glibc库版本低于环境要求； 
  2. Conda环境与Slurm作业调度系统集成存在兼容性困难。 
  解决方案：委托第三方将完整依赖环境封装为Apptainer镜像，目前已初步解决环境一致性与可移植性问题。 
  后续建议：为保障环境交付的稳定性与可靠性，建议后续以标准化容器镜像作为交付物，确保跨平台一致性和部署效率。
  二、平台与集群侧适配问题 
  1. 软件授权（License）限制：现有整车外气动仿真与铝材均热仿真等场景均涉及第三方软件授权约束。目前采取规避策略以避免License冲突，建议后续尽力规避强绑定License的情况。 
  2. 集群侧软件适配与验证：需在超算互联网集群环境中完成软件安装、环境依赖调试及脚本全流程测试，确保现有工作流与脚本可在咱们的集群中完整运行。
  三、计算场景说明与报告规范需求 
  为提升研发流程构建效率，建议对接收的计算场景脚本或工作流提供以下说明： 
  - 场景简述与功能标注，供研发参考并构建新流程； 
  - 输出结果文件的简要描述； 
  - 计算场景的整体说明报告，需包含： 
    - 目标：场景解决的问题或验证的假设； 
    - 过程：关键步骤与资源配置； 
    - 结果：主要输出与初步结论； 
    - 预期：成果应用方向或后续改进点。


